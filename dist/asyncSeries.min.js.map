{"version":3,"file":"asyncSeries.min.js","sources":["../index.js"],"sourcesContent":["/**\n * Asynchronously process a list of items, consecutively.\n *\n * @param Array array\n * @param Function(value, index, array) iteratee\n *\n * @return Promise resolve when done, reject on first error\n */\nexport function forEach(array, iteratee) {\n    const { length } = array;\n    let index = -1;\n\n    return Promise.resolve()\n    .then(function _proc() {\n        ++index;\n        if(index < length) {\n            return Promise.resolve(iteratee.call(array, array[index], index, array)).then(_proc);\n        }\n    });\n}\n\n/**\n * Asynchronously map a list of items, consecutively.\n *\n * @param Array array\n * @param Function(value, index, array, prevValue) iteratee\n * @param any firstValue The `prevValue` of first call to iteratee\n *\n * @return Promise(array) array mapped, reject on first error\n */\nexport function map(array, iteratee, firstValue) {\n    const result = [];\n    const { length } = array;\n    let index = -1;\n\n    return Promise.resolve(firstValue)\n    .then(function _proc(prevValue) {\n        if(index >= 0) {\n            result[index] = prevValue;\n        }\n        ++index;\n        if(index < length) {\n            return Promise.resolve(iteratee.call(array, array[index], index, array, prevValue)).then(_proc);\n        }\n        return result;\n    });\n}\n\n/**\n * Asynchronously reduce a list of items, consecutively.\n *\n * @param Array array\n * @param Function(accumulator, currentValue, index, array) reducer\n * @param any initialValue\n *\n * @return Promise(any) resolve to the last returned value when done, reject on first error\n */\nexport function reduce(array, reducer, initialValue) {\n    const { length } = array;\n    let index = -1;\n    if(arguments.length<3) {\n        initialValue = array[0];\n        ++index;\n    }\n\n    return Promise.resolve(initialValue)\n    .then(function _proc(accumulator) {\n        ++index;\n        if(index < length) {\n            return Promise.resolve(reducer.call(array, accumulator, array[index], index, array)).then(_proc);\n        }\n        return accumulator;\n    });\n}\n"],"names":["array","iteratee","length","index","Promise","resolve","then","_proc","call","firstValue","result","prevValue","reducer","initialValue","arguments","accumulator"],"mappings":"mNAQO,SAAiBA,EAAOC,SACrBC,OAAEA,GAAWF,MACfG,GAAS,SAENC,QAAQC,UACdC,MAAK,SAASC,SACTJ,EACCA,EAAQD,SACAE,QAAQC,QAAQJ,EAASO,KAAKR,EAAOA,EAAMG,GAAQA,EAAOH,IAAQM,KAAKC,aAcnF,SAAaP,EAAOC,EAAUQ,SAC3BC,EAAS,IACTR,OAAEA,GAAWF,MACfG,GAAS,SAENC,QAAQC,QAAQI,GACtBH,MAAK,SAASC,EAAMI,UACdR,GAAS,IACRO,EAAOP,GAASQ,KAElBR,EACCA,EAAQD,EACAE,QAAQC,QAAQJ,EAASO,KAAKR,EAAOA,EAAMG,GAAQA,EAAOH,EAAOW,IAAYL,KAAKC,GAEtFG,eAaR,SAAgBV,EAAOY,EAASC,SAC7BX,OAAEA,GAAWF,MACfG,GAAS,SACVW,UAAUZ,OAAO,IAChBW,EAAeb,EAAM,KACnBG,GAGCC,QAAQC,QAAQQ,GACtBP,MAAK,SAASC,EAAMQ,WACfZ,EACCA,EAAQD,EACAE,QAAQC,QAAQO,EAAQJ,KAAKR,EAAOe,EAAaf,EAAMG,GAAQA,EAAOH,IAAQM,KAAKC,GAEvFQ"}