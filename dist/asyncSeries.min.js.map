{"version":3,"file":"asyncSeries.min.js","sources":["../index.js"],"sourcesContent":["/**\n * Asynchronously process a list of items, consecutively.\n *\n * @param Array array\n * @param Function(value, index, array) iteratee\n *\n * @return Promise resolve when done, reject on first error\n * @version 1.0.3\n */\nexport function forEach(array, iteratee) {\n    const { length } = array;\n    let index = -1;\n\n    return Promise.resolve()\n    .then(function _proc() {\n        ++index;\n        if(index < length) {\n            return Promise.resolve(iteratee.call(array, array[index], index, array))\n                .then(_proc)\n            ;\n        }\n    });\n}\n\n/**\n * Asynchronously map a list of items, consecutively.\n *\n * @param Array array\n * @param Function(value, index, array, prevValue) iteratee\n * @param any firstValue The `prevValue` of first call to iteratee\n *\n * @return Promise(array) array mapped, reject on first error\n * @version 1.0.3\n */\nexport function map(array, iteratee, firstValue) {\n    const result = [];\n    const { length } = array;\n    let index = -1;\n\n    return Promise.resolve(firstValue)\n    .then(function _proc(prevValue) {\n        if(index >= 0) {\n            result[index] = prevValue;\n        }\n        ++index;\n        if(index < length) {\n            return Promise.resolve(iteratee.call(array, array[index], index, array, prevValue))\n                .then(_proc)\n            ;\n        }\n        return result;\n    });\n}\n\n/**\n * Asynchronously reduce a list of items, consecutively.\n *\n * @param Array array\n * @param Function(accumulator, currentValue, index, array) reducer\n * @param any initialValue\n *\n * @return Promise(any) resolve to the last returned value when done, reject on first error\n * @version 1.0.3\n */\nexport function reduce(array, reducer, initialValue) {\n    const { length } = array;\n    let index = -1;\n    if(arguments.length < 3) {\n        initialValue = array[0];\n        ++index;\n    }\n\n    return Promise.resolve(initialValue)\n    .then(function _proc(accumulator) {\n        ++index;\n        if(index < length) {\n            return Promise.resolve(reducer.call(array, accumulator, array[index], index, array))\n                .then(_proc)\n            ;\n        }\n        return accumulator;\n    });\n}\n"],"names":["array","iteratee","length","index","Promise","resolve","then","_proc","call","firstValue","result","prevValue","reducer","initialValue","arguments","accumulator"],"mappings":"6PASO,SAAiBA,EAAOC,OACnBC,EAAWF,EAAXE,OACJC,GAAS,SAENC,QAAQC,UACdC,MAAK,SAASC,SACTJ,EACSD,SACAE,QAAQC,QAAQJ,EAASO,KAAKR,EAAOA,EAAMG,GAAQA,EAAOH,IAC5DM,KAAKC,aAgBf,SAAaP,EAAOC,EAAUQ,OAC3BC,EAAS,GACPR,EAAWF,EAAXE,OACJC,GAAS,SAENC,QAAQC,QAAQI,GACtBH,MAAK,SAASC,EAAMI,UACdR,GAAS,IACRO,EAAOP,GAASQ,KAElBR,EACSD,EACAE,QAAQC,QAAQJ,EAASO,KAAKR,EAAOA,EAAMG,GAAQA,EAAOH,EAAOW,IACnEL,KAAKC,GAGPG,eAcR,SAAgBV,EAAOY,EAASC,OAC3BX,EAAWF,EAAXE,OACJC,GAAS,SACVW,UAAUZ,OAAS,IAClBW,EAAeb,EAAM,KACnBG,GAGCC,QAAQC,QAAQQ,GACtBP,MAAK,SAASC,EAAMQ,WACfZ,EACSD,EACAE,QAAQC,QAAQO,EAAQJ,KAAKR,EAAOe,EAAaf,EAAMG,GAAQA,EAAOH,IACxEM,KAAKC,GAGPQ"}